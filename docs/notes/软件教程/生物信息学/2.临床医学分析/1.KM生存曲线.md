---
title: KM生存曲线
createTime: 2025/01/12 00:16:53
permalink: /tutorials/bioinfomatics/clinical/kmplot/
---
## **基础教程**
### **生存过程的描述**

::: tip 基础
- `survival`包用于构建生存曲线数据，`survminer`包用于生存曲线可视化
- 使用`survival`包中的`lung`数据集用于演示，`lung`是关于肺癌患者的生存数据
- 数据中 `time`是生存时间，以天为单位，`status`是生存状态，1代表删失，2代表死亡。
- 一般在生存分析中我们喜欢用1代表死亡，用0代表删失，所以我们更改一下（其实不改也可以，你记住就行）
- 生存时间和生存状态用`survival`包中`Surv()`函数放到一起，可以生成有`+`的就是截尾数据
- 可以使用寿命表法或者K-M曲线描述生成数据，在R中通过`survival`包中`survfit()`函数实现
- 使用`survminer`包中的`ggsurvplot()`函数可视化生存曲线，横坐标是生存时间，纵坐标是生存率
:::

::: tabs

@tab 示例数据`lung`
```R
library(survival)
library(survminer)

# help("lung")
df <- lung
df$status <- ifelse(df$status == 2,1,0)
str(df)
```
@tab 生成截尾数据(寿命表)
```R
Surv(time = lung$time, event = lung$status)
```
@tab 构建生存曲线
```R
# 1 代表 全部类别
fit <- survfit(Surv(time, status) ~ 1, data = df)

# 寿命表，surv_summary比默认的summary()更好
surv_summary(fit)
```
@tab 生存曲线可视化
```R
ggsurvplot(fit,
           conf.int = TRUE, # 可信区间
           palette= 'blue', # 更改配色
           surv.median.line = "hv", # 中位生存时间
           ggtheme = theme_bw() # 更改主题
           
)
```
:::

### **生存过程的比较**

::: tip 实现原理和方法
- 通过某个变量把数据分为多组，然后检验**不同组别**之间的生存时间（生存曲线）有无差别，则可以通过`logrank检验`或者`breslow检验`
- R语言中通过`survival`包中的`survdiff()`函数实现`logrank检验`
- `broom包`提取结果数据
- 对于不同组别之间生存曲线的检验，也可以直接通过`K-M()`图示的方法
:::

:::tabs

@tab logrank检验
```R
fit <- survdiff(Surv(time, status) ~ sex, data = df)
fit
```

@tab boom提取结果数据
```R
broom::tidy(fit)
broom::glance(fit)
```

@tab KM生存曲线
```R
fit.logrank <- survfit(Surv(time, status) ~ sex, data = df)

# 或 直接
# fit <- survfit(Surv(time, status) ~ sex, data = df)

surv_summary(fit.logrank) # 查看寿命表

# boom::tidy(fit.logrank)
# summary(fit.logrank)$table
# summary(fit.logrank)
```

@tab 可视化KM生成曲线
```R
ggsurvplot(fit.logrank, # 必需，生成曲线数据
           data = df, # 非必需，绘图数据，缺省提取fit数据
           surv.median.line = "hv", # 添加中位生存时间
           
           # 改变图例: 标题 & 标签
           legend.title = "Sex",
           legend.labs = c("Male", "Female"),
           
           # 添加 p值 and 置信区间
           pval = TRUE, # 这里P值直接写数字也行
           conf.int = TRUE,
           
           # 添加风险表
           risk.table = TRUE, 
           tables.height = 0.2, # 风险表高度
           tables.theme = theme_cleantable(), # 风险表主题
           
           ncensor.plot = TRUE,
           
           # Color palettes. Use custom color: c("#E7B800", "#2E9FDF"),
           # or brewer color (e.g.: "Dark2"), or ggsci color (e.g.: "jco")
           palette = c("#E7B800", "#2E9FDF"),
           ggtheme = theme_bw(), # Change ggplot2 theme
           
           # 修改字体、字号和颜色
           main = "Survival curve",
           font.main = c(16, "bold", "darkblue"),
           font.x = c(14, "bold.italic", "red"),
           font.y = c(14, "bold.italic", "darkred"),
           font.tickslab = c(12, "plain", "darkgreen")
)
```
:::

## **进阶教程1: 连续变量分组最佳切点的确定**

:::tip 最佳切点
- 确定最佳切点的R包非常多
- `survminer`包中的`surv_cutpoint()`函数可用于寻找连续性数据分组最佳切点
- 示例数据 `myeloma` 用于演示最佳切点操作，`myeloma`是关于多发性骨髓瘤患者的生存时间数据
- `molecular_group`患者分子亚群, `chr1q21_status`1q21染色体的扩增状态
- `treatment`治疗方法,`event`生存状态0=存活，1=死亡，`time`存活时间（月）
- `CCND1`、`CRIM1`、`DEPDC1`、`IRF4`、`TP53`、`WHSC1`对应于特定基因的基因表达水平
:::

:::tabs
@tab 示例数据`myeloma`
```R
rm(list = ls())

# help("myeloma") # 查看数据详情

df <- myeloma
head(df)
```
@tab 最佳切点
```R
# 1.寻找指定的连续变量的最佳切点，分成 high 和 low 组
res.cut <- surv_cutpoint(df, time = "time", event = "event",
                         variables = c("DEPDC1", "WHSC1", "CRIM1") # 找这3个变量的最佳切点
                         )

summary(res.cut)

# 2. 查看根据最佳切点进行分组后的数据分布情况
plot(res.cut, "DEPDC1", palette = "npg") # DEPDC1

## $DEPDC1
```
@tab 最佳切点分组
```R
# 3. 根据最佳切点重新划分数据，这样数据就根据最佳切点变成了高表达/低表达组
res.cat <- surv_categorize(res.cut)
head(res.cat)

```
@tab 最佳切点生存曲线
```R
fit <- survfit(Surv(time, event) ~DEPDC1, data = res.cat)
ggsurvplot(fit, data = res.cat, risk.table = TRUE, conf.int = TRUE)
```
:::


## **进阶教程2：多个分类变量KM曲线绘制**

### **单图绘制**
```R
fit <- survfit(Surv(time, status) ~ sex + ph.ecog, lung)
ggsurv <- ggsurvplot(fit,lung,pval=TRUE,risk.table=TURE,risk.table.height=0.3)
ggsurv
```
### **分面绘制**

::: tip colon 数据
- 以`survival`包中`colon`数据集为例，使用3个分类变量：`sex`、`rx`、`adhere`
- 数据详情 `help(colon)`
:::

- [x] **方法1**
```R
# 构建生成函数
fit <- survfit(Surv(time, status) ~ sex + rx + adhere, data = colon )

# 将生存曲线保存为一个对象

ggsurv <- ggsurvplot(fit3, data = colon,
  fun = "cumhaz", conf.int = TRUE,
  risk.table = TRUE, risk.table.col="strata",
  ggtheme = theme_bw())

```


- [x] **方法2**





## **进阶教程3：KM曲线可视化的精细设置**

:::tip 可视化设置说明
- 图形属性
- 生存曲线 `KM Plot`
- 风险表 `Risk Table`
- 删失点 `Ncensor Plot`
:::

- [X] **自定义一个函数，用来更改各种样式**

:::tabs

@tab 样式设置函数
```R
# 更改生存曲线，risk table，ncensor plot的字体大小、类型、颜色
customize_labels <- function (p, 
                              font.title = NULL,
                              font.subtitle = NULL, 
                              font.caption = NULL,
                              font.x = NULL, 
                              font.y = NULL, 
                              font.xtickslab = NULL, 
                              font.ytickslab = NULL
                             )
{
  original.p <- p
  if (is.ggplot(original.p)) {
    list.plots <- list(original.p)
  } else if(is.list(original.p)) {
    list.plots <- original.p
  } else {
    stop("Can't handle an object of class ", class (original.p))
  }

  .set_font <- function(font) {
    font <- ggpubr:::.parse_font(font)
    ggtext::element_markdown (size = font$size, face = font$face, colour = font$color)
  }

  for(i in 1:length(list.plots)) {
    p <- list.plots[[i]]
    if(is.ggplot(p)){
      if (!is.null(font.title)) p <- p + theme(plot.title = .set_font(font.title))
      if (!is.null(font.subtitle)) p <- p + theme(plot.subtitle = .set_font(font.subtitle))
      if (!is.null(font.caption)) p <- p + theme(plot.caption = .set_font(font.caption))
      if (!is.null(font.x)) p <- p + theme(axis.title.x = .set_font(font.x))
      if (!is.null(font.y)) p <- p + theme(axis.title.y = .set_font(font.y))
      if (!is.null(font.xtickslab)) p <- p + theme(axis.text.x = .set_font(font.xtickslab))
      if (!is.null(font.ytickslab)) p <- p + theme(axis.text.y = .set_font(font.ytickslab))
      list.plots[[i]] <- p
    }
  }

  if (is.ggplot(original.p)) {
    list.plots[[1]]
  } else {
    list.plots
  }
}
```

@tab KM曲线基础绘图
```R
library(survival)
library(survminer)

fit <- survfit(Surv(time, status) ~ sex, data = lung)

ggsurv <- ggsurvplot(
           fit, # 拟合数据                    
           data = lung, # 原始数据             
           risk.table = TRUE,  # 风险表
           ncensor.plot = TRUE, # 删失图       
           ggtheme = theme_light(),  # 图形主题
        )
```

:::


## **进阶教程4：公式函数设置**

::: Caution surv_fit()函数
- **使用公式构建生成数据时，用surv_fit()函数，才能正常使用ggsurvplot()可视化**
:::

```R
timeVar <- "time"
eventVar <- "status"
factorVars <- c("sex","ph.ecog")

formula <- as.formula(
          paste0(
            paste0(
              "Surv(",
              timeVar,
              ",",
              eventVar,
              ") ~ "
            ),
            paste0(factorVars,collapse = "+")
          )
        )

fit <- surv_fit(formula, lung)

ggsurv <- ggsurvplot(fit, lung)
```